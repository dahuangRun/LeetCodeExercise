# LeetCode刷题笔记
## 每道题目需要注意的地方
1. **两数之和**
	1. 可以用暴力方法
	2. 推荐使用HashMap(key,value)处理
2. **两数相加**
	1. 链表的相加 (✖)
3. 最长子串长度(✖)    变形：求最长子串    
	思路：因为求解字符串中不包含重复字符的最长子串的长度。因为可以利用到java中天然不包含重复元素的结构Set。  
		1. 首先肯定得做原字符串是否是空字符串的判断  
		2. 可以定义两个变量pre(表示子串的前端)、i(表示字符串的当前位置)、maxLength(当前子串最长的长度)  
		3. 开始循环整个字符串，如果遇到了相同的字符，则计算当前子串长度，并且与maxLength做比较,并且pre的位置转移到(i+1)的位置，
				当然，这中间肯定需要再加一层while循环，用于转移pre。   
		4. 最后比较前面循环中的maxLength和最后的(i-pre)之间的大小。 
			
	3.1 **最长子串**  
		假设本题要求找出无重复的最长子串，则需要用两个变量保存窗口的左右位置，每当max_str更新的时候，
		就需要更新此时的窗口左右位置。最终使用s.substring(left, right)获取最长子串。

4. 最长回文子串    	
	1. 第一种方法：提供最暴力的方法   时间复杂度接近  O(n^3)   (超时)    
		1. 从最长的字符串开始迭代，如果找到了回文字符串则终止循环   
		2. 采用由两端 到中心的方法检验字符串是否为回文字符串。  
	2. 第二种方法：采用动态规划的方式。  时间复杂度O(n^2),空间O(n^2) 
		1. dp[i][j] 表示子串s[i…j]是否是回文
		2. 初始化：dp[i][i] = true (0 <= i <= n-1);  dp[i][i-1] = true (1 <= i <= n-1); 其余的初始化为false
		3. dp[i][j] = (s[i] == s[j] && dp[i+1][j-1] == true)(内部再用两个循环来遍历)
		4. 注意具体代码中：可以将字符串的长度按照length = 1 length = 2 、length > 2 来分别讨论，分别用k、i、j来表示长度、开始、结束
	3. 第三种方式：分别以每一个字符为中心，求解每个字符最长的偶数回文串及奇数回文串    时间复杂度O(n^2)，空间O(1)  
		1. 特点：上面两种方式，都只是定义start、及结果的length，而不是直接求end的位置。
		2. 主要是在一个for循环中，做两个while循环，分别做奇偶处理
6. 反转整数 
	1. 这个自己使用StringBuffer来处理的，全部的知识都和String相关，个人认为也是可以的，但是系统没有通过。
	2. 但是，估计这道题目目的在与考察，类似于栈的运用，及换个手段来判断是否存在溢出的情况。




	