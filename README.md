# LeetCode刷题笔记
## 每道题目需要注意的地方
1. **两数之和**
	1. 可以用暴力方法
	2. 推荐使用HashMap(key,value)处理
2. **两数相加**
	1. 链表的相加 (✖)
3. 最长子串长度(✖)    变形：求最长子串    
	思路：因为求解字符串中不包含重复字符的最长子串的长度。因为可以利用到java中天然不包含重复元素的结构Set。  
		1. 首先肯定得做原字符串是否是空字符串的判断  
		2. 可以定义两个变量pre(表示子串的前端)、i(表示字符串的当前位置)、maxLength(当前子串最长的长度)  
		3. 开始循环整个字符串，如果遇到了相同的字符，则计算当前子串长度，并且与maxLength做比较,并且pre的位置转移到(i+1)的位置，
				当然，这中间肯定需要再加一层while循环，用于转移pre。   
		4. 最后比较前面循环中的maxLength和最后的(i-pre)之间的大小。 
			
	3.1 **最长子串**  
		假设本题要求找出无重复的最长子串，则需要用两个变量保存窗口的左右位置，每当max_str更新的时候，
		就需要更新此时的窗口左右位置。最终使用s.substring(left, right)获取最长子串。

5. 最长回文子串    	
	1. 第一种方法：提供最暴力的方法   时间复杂度接近  O(n^3)   (超时)    
		1. 从最长的字符串开始迭代，如果找到了回文字符串则终止循环   
		2. 采用由两端 到中心的方法检验字符串是否为回文字符串。  
	2. 第二种方法：采用动态规划的方式。  时间复杂度O(n^2),空间O(n^2) 
		1. dp[i][j] 表示子串s[i…j]是否是回文
		2. 初始化：dp[i][i] = true (0 <= i <= n-1);  dp[i][i-1] = true (1 <= i <= n-1); 其余的初始化为false
		3. dp[i][j] = (s[i] == s[j] && dp[i+1][j-1] == true)(内部再用两个循环来遍历)
		4. 注意具体代码中：可以将字符串的长度按照length = 1 length = 2 、length > 2 来分别讨论，分别用k、i、j来表示长度、开始、结束
	3. 第三种方式：分别以每一个字符为中心，求解每个字符最长的偶数回文串及奇数回文串    时间复杂度O(n^2)，空间O(1)  
		1. 特点：上面两种方式，都只是定义start、及结果的length，而不是直接求end的位置。
		2. 主要是在一个for循环中，做两个while循环，分别做奇偶处理
6. z字形变化
	1. 第一种：按照每个字符所在的行进行排序，从左到右遍历字符串，将字符串填到合适的行，只有到移到最上方和最小法时方向才会改变。
	2. 第二种：按行访问，找出每个元素下标索引对应的规律。
		
		
7. 反转整数 
	1. 这个自己使用StringBuffer来处理的，全部的知识都和String相关，个人认为也是可以的，但是系统没有通过。
	2. 但是，估计这道题目目的在与考察，类似于栈的运用，及换个手段来判断是否存在溢出的情况。

8. 字符串整数
	1. 思路：去掉首尾段的空白字符、判断是否为空、标记正负、剔除空白字符、判断数值是否超过范围

9. 回文数
	1. 第一种：将数字转化为字符串
	2. 第二种：对数字求余，将余数分别存储在栈和队列中，利用一个“先进后出”，一个“先进先出”的特点



# 剑指Offer笔记
## 每道题目需要注意的地方
1. **二维数组的查找**
	1. 思路：因为矩阵是有序的，所有可以将初始值定在左下角。(当然也可以定义在右上角)    
		从左下角来看，如果target大于左下角的数，则向右移;小于,则向左移动。
			
2. **替换空格**
	1. 这个主要利用replaceAll()。
		
3. **从头到尾打印链表**
	1. 第一种方法：可以利用链表和栈的不同属性。栈(先进后出)，链表(先进可以先出).
	2. 递归(这种方法比较奇妙).

4. **重建二叉树**  
	其实就是根据前序遍历和中序遍历还原二叉树
	1. 第一个方法：肯定利用递归的思想。(技巧：重新构建一个方法)。前序遍历第一个元素肯定是二叉树的根节点，再根据该节点二分中序遍历数组。

5. **重建二叉树**

	